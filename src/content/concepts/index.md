---
title: Основы
sort: 1
contributors:
  - TheLarkInn
  - jhnns
  - grgur
  - johnstew
  - jimrfenner
  - TheDutchCoder
  - adambraimbridge
  - EugeneHlushko
  - jeremenichelli
  - arjunsajeev
  - byzyk
  - yairhaimo
  - farskid
  - LukeMwila
  - maikudou
---

__webpack__, по своей сути — это _сборщик статических модулей_ для современных, написанных на JavaScript веб-приложений. webpack, анализирует ваше приложение, строит внутренний [граф зависимостей](/concepts/dependency-graph/) между модулями, которые то использует и генерирует на основе графа одну или несколько _сборок_ или, иначе, _бандлов_.

T> Более подробно о разнице между модулями JavaScript и модулями webpack можно прочитать [там](/concepts/modules).

Несмотря на то, что начиная с версии 4.0.0 __webpack не требует наличия конфигурационного файла__, он [очень гибко настраивается](/configuration) под ваши нужды.

Для начала нужно усвоить несколько __Основных Понятий__:

- [Точка входа](#entry)
- [Выхлоп](#output)
- [Загрузчики](#loaders)
- [Плагины](#plugins)
- [Режим](#mode)
- [Совместимость с браузерами](#browser-compatibility)

Этот документ задумывался как __высокоуровневый__ обзор основных понятий со ссылками на более детализированные примеры использования отдельных концепций.

Обратитесь к следущим ресурсам (на английском), чтобы лучше понимать идеи, заложенные в сборщики модулей и как те работают "под капотом":

- [Сборка приложения вручную](https://www.youtube.com/watch?v=UNMkLHzofQI)
- [Пишем простой сборщик модулей вживую](https://www.youtube.com/watch?v=Gc9-7PBqOC8)
- [Подробное объяснение простого сборщика моулей](https://github.com/ronami/minipack)


## Точка входа

__Точка входа__ указывает webpack'у с какого модуля тот должен начать строить свой внутренний [граф зависимостей](/concepts/dependency-graph/). webpack определит, от каких еще модулей эта точка входа зависит как напрямую, так и косвенно.

Точка входа по умолчанию — `./src/index.js`, однако вы можете указать другую точку входа (или несколько) в поле __entry__ [конфгурационного файла](/configuration). Например:

__webpack.config.js__

``` js
module.exports = {
  entry: './path/to/my/entry/file.js'
};
```

T> Подробнее о точках входа — в [соответствующем разделе](/concepts/entry-points).


## Выхлоп

Поле __output__ (выхлоп) указывает, куда webpack'у следует поместить сгенерированные сборки, и как эти файлы назвать. По умолчанию это — `./dist/main.js` для основной сборки и папка `./dist` для любых других файлов.

Эту часть процесса можно настроить заполнив поле `output` в конфигурационном файле:

__webpack.config.js__

```javascript
const path = require('path');

module.exports = {
  entry: './path/to/my/entry/file.js',
  output: {
    path: path.resolve(__dirname, 'dist'),
    filename: 'my-first-webpack.bundle.js'
  }
};
```

В приведенном выше примере мы использовали `output.filename` и `output.path`, чтобы указать webpack'у как назвать получившуюся сборку и куда ее следует положить. Если вам интересно, что это за path, который мы импортировали в самом начале, то это встроенный в [Node.js модуль](https://nodejs.org/api/modules.html), который используют для различной работы с файловыми путями.

T> Поле `output` достаточно [гибко настраивается](/configuration/output) и если вы хотите познакомиться более подробно со стоящими за ним концепциями, то почитайте более подробно в соответствующем [разделе](/concepts/output).


## Загрузчики

Из коробки webpack умеет работать только с файлами JavaScript и JSON. Чтобы webpack смог обработать другие типы файлов, преобразовать их в валидные [модули](/concepts/modules) и включить те в граф зависимостей необходимы __загрузчики__.

W> Обратите внимание, что способность импортировать любые типы модулей с помощью директивы `import`, такие как, например, `.css` файлы, это особенность webpack'а и другие сборщики могут не иметь такой возможности. Мы считаем оправданным такое расширение языка, потому что оно позволяет разработчикам строить более точный граф зависимостей. 

В конфигурационном файле поле __loaders__ имеет два высокоуровневых свойства:

1. Свойство `test` (соответствие) определяет какой файл или файлы необходимо преобразовывать.
2. Свойство `use` (использовать) указывает как загрузчик для этого использовать.

__webpack.config.js__

```javascript
const path = require('path');

module.exports = {
  output: {
    filename: 'my-first-webpack.bundle.js'
  },
  module: {
    rules: [
      { test: /\.txt$/, use: 'raw-loader' }
    ]
  }
};
```

Приведенная конфигурация определяет поле `rules` (правила) для отдельного модуля с помощью двух обязательных свойств: `test` и `use`. Это сообщает webpack'у следующее:

> "Эй, компилятор webpack, когда встретишь внутри инструкции `require()`/`import` путь, который кончается на '.txt', то перед тем как добавлять его в сборку, преобразуй его __используя__ `raw-loader`"

W> Важно помнить, что правила в конфигурационном файле определяются в поле `module.rules` a не просто `rules`. Если вы сделаете это неправильно, то webpack вас об этом предупредит.

W> Имейте ввиду, что регулярные выражения в качестве правил соответствия не должны заключаться в ковычки. То есть `/\.txt$/` это не то же самое, что `'/\.txt$/'`/ `"/\.txt$/"`. Первое указывает webpack'у искать файлы, имена которых оканчиваются на .txt, тогда как последнее предсписывает искать единственный файл с абсолютным путем '.txt'; скорее всего, это не то, что бы вы имели ввиду.

Прочие настройки можно узнать в разделе о [загрузчиках](/concepts/loaders).


## Плагины

Загрузчики используются для преобразования определенных типов модулей, плагины же помогают выполнять более широкий спектр задач, таких, например, как оптимизация сборки, работа с ресурсами и внедрение переменных окружения.

T> Ознакомьтесь с [интерфейсом плагинов](/api/plugins) и тем, как его использовать для расширения возможностей webpack'а.

Чтобы использовать плагин, необходимо импортировать его директивой `require()` и добавить в массив `plugins`. Большинство плагинов кастомизируются с помощью настроек. Из-за того что в одном конфигурационном файле вы можете использовать определенный плагин несколько раз с разными целями, вам нужно создать его экземпляр с помощью оператора `new`.


__webpack.config.js__

```javascript
const HtmlWebpackPlugin = require('html-webpack-plugin'); //устанавливается  через npm
const webpack = require('webpack'); //чтобы использоваьб встроенные плагины

module.exports = {
  module: {
    rules: [
      { test: /\.txt$/, use: 'raw-loader' }
    ]
  },
  plugins: [
    new HtmlWebpackPlugin({template: './src/index.html'})
  ]
};
```

В вышеприведенном примере плагин `html-webpack-plugin` создает для вашего приложения файл HTML, автоматически внедряя в него все сгенерированные сборки.

T> webpack поставляется со множестовм плагинов "из коробки"! Вот их [список](/plugins).

Использовать плагины в вашем конфигурационном файле просто, однако есть несколько их применений, которые требуют дополнительного изучения. Подробнее [здесь](/concepts/plugins).


## Режим

Устанавливая параметр `mode` (режим) в `development` (разработка), `production` (продакшн) или `none` (никакой), можно заставить webpack использовать встроенные оптимизации, подходящие к каждому из окружений. Значение по умолчанию — `production`.

```javascript
module.exports = {
  mode: 'production'
};
```

Прочитайте про [настройку режима](/concepts/mode) и о том, какие конкретно оптимизации включаются при определенных значениях


## Совместимость с браузерами

webpack поддерживает все [совместимые с ES5](https://kangax.github.io/compat-table/es5/) браузеры (IE8 и ниже не поддерживаются). webpack использует `Promise` (промисы) для директив `import()` и `require.ensure()`. Для поддержки более старых браузеров необходимо будет [загрузить полифил](/guides/shimming/) до использования этих выражений.
